<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ActionScript | Mike Chambers]]></title>
  <link href="http://mikechambers.github.io//blog/categories/actionscript/atom.xml" rel="self"/>
  <link href="http://mikechambers.github.io//"/>
  <updated>2013-12-16T17:07:46-08:00</updated>
  <id>http://mikechambers.github.io//</id>
  <author>
    <name><![CDATA[Mike Chambers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Flash Roadmap Whitepaper Published]]></title>
    <link href="http://mikechambers.github.io//2012/02/22/flash-roadmap-whitepaper-published/"/>
    <updated>2012-02-22T12:49:01-08:00</updated>
    <id>http://mikechambers.github.io//2012/02/22/flash-roadmap-whitepaper-published</id>
    <content type="html"><![CDATA[<p>We have just posted a new whitepaper on Adobe.com. The whitepaper, titled <a href="http://www.adobe.com/go/flashplayer_whitepaper">Adobe roadmap for the Flash runtimes</a> lays out the 1 to 2 year roadmap for the Flash runtimes (primarily Adobe AIR and Flash Player). This includes information on specific planned releases, longer term player work, and supported platforms.</p>

<!--more-->


<p>This is actually the third Flash platform white paper that we have released in the past week (<a href="http://www.adobe.com/go/flashplatform_whitepapers">Adobe’s view of Flex and its commitments to Flex in the future</a>, <a href="http://www.adobe.com/go/flashplatform_whitepapers">Adobe Flash Player and Adobe AIR security</a>), and is a part of a larger process of trying to provide clear and open communications around our thinking and plans for the Flash platform.</p>

<p>The primary goal of the whitepaper is to have a single definitive resource that provides clear insight into Adobe&rsquo;s plans and thinking around the roadmap for the Flash runtimes.</p>

<p>While in the past we have been open around our plans for the Flash runtimes, there was never a single resource where developers could find all of the latest thinking and plans around those runtimes. News and information was often spread across multiple resources, including the Adobe website, Adobe blogs, personal blogs, forum posts, and even tweets. We will still leverage these various means of communications, but they will build on top of the whitepaper. As our thinking and plans around the Flash runtimes evolve, we will update the whitepaper with those new plans.</p>

<p>This is also part of some more extensive changes at Adobe to help us avoid some of the communication missteps which have caused so much consternation and frustration over the past couple of months. Not only does the publication of the whitepaper give us a clear and concise way to publish information and plans around the Flash runtimes, it also provides developers with a definitive resources on where to get the most current information around the Flash platform.</p>

<p>This speaks to another goal of the whitepapers. We understand that we have damaged our trust and credibility with the community over how we have communicated some of the recent changes around the Flash platform and that trying to regain that trust is a long term process. We have to be clear and open around our plans around the Flash runtimes, and then demonstrate that we can follow up those plans with actions. This whitepaper lays the foundation of the first part of that, and hopefully our actions and runtime releases over the next 6 to 12 months will demonstrate the second part.</p>

<p>Finally, as part of the release of the whitepaper, I and some other members of the Flash and evangelist teams will be visiting user groups world wide. This will be an opportunity to go over the roadmap in more detail, have a frank and open discussion around recent changes around Flash, as well as discuss Flash&rsquo;s role on the web and how it related to HTML5. The first set of meetings are over the <a href="http://www.mikechambers.com/blog/2012/02/13/in-europe-to-discuss-flash-roadmap/">next two weeks in Europe</a>, and we will announce more for North and South America, and Asia over the next couple of weeks. If you would be interested in hosting a meeting, just shoot me an email at <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#109;&#x65;&#115;&#x68;&#x40;&#x61;&#x64;&#x6f;&#98;&#101;&#46;&#x63;&#x6f;&#x6d;&#x2e;">&#x6d;&#x65;&#115;&#x68;&#64;&#97;&#x64;&#111;&#98;&#101;&#46;&#x63;&#x6f;&#x6d;&#x2e;</a></p>

<p>We are already planning an update for the whitepaper in a couple of weeks, so if you find anything is not clear, or would like it to cover other topics, please post them in the comments, or shoot me an email.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FITC Amsterdam : Building High Performance iPhone Applications With ActionScript 3]]></title>
    <link href="http://mikechambers.github.io//2010/01/25/fitc-amsterdam-building-high-performance-iphone-applications-with-actionscript-3/"/>
    <updated>2010-01-25T12:13:01-08:00</updated>
    <id>http://mikechambers.github.io//2010/01/25/fitc-amsterdam-building-high-performance-iphone-applications-with-actionscript-3</id>
    <content type="html"><![CDATA[<p>Sorry for the two month hiatus on posting. I was on a sabbatical and vacation from work for the last 6 weeks of 2009, and have spent the first couple of weeks of 2010 busy working on code, and preparing some events for the spring (more on that in another post).</p>

<p>Some of the stuff I have continued to spend a lot of time working on, has been <a href="http://labs.adobe.com/technologies/flashcs5/appsfor_iphone/">building iPhone content using the Flash CS5 private beta</a>. I have been doing a lot of work on trying to figure out how to get the best performance, and understand the limits of Flash content on the device. I plan to make a separate post on that in the next couple of days.</p>

<!--more-->


<p>Anyways, the conference season is about to be in full swing, and the first talk I am doing this year, will be at <a href="http://www.fitc.ca/events/about/?event=101">FITC Amsterdam</a> next month on Flash and iPhone. The talk is titled &ldquo;<a href="http://www.fitc.ca/events/presentations/presentation.cfm?event=101&amp;presentation_id=1130">Building High Performance iPhone Applications with ActionScript 3</a>&rdquo; and will discuss how to get the best performance from your Flash content, as well as what type of Flash content is best suited for the device. In addition to talking about some general tips and tricks, I will also be discussing some of the new hardware accelerated APIs, and showing some games I have been working on (including my new game <a href="http://www.twitpic.com/q00ox">Unicorn Bacon Adventure!</a>).</p>

<p>If you are in Europe, and haven&rsquo;t signed up for FITC yet, then what are you waiting for?!?!? This is one of the best conferences in the world, and the <a href="http://www.fitc.ca/events/speakers/?event=101">speaker line up for Amsterdam</a> is simply amazing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Case Study : ActionScript 3 Performance Optimization]]></title>
    <link href="http://mikechambers.github.io//2009/10/13/case-study-actionscript-3-performance-optimization/"/>
    <updated>2009-10-13T13:57:01-07:00</updated>
    <id>http://mikechambers.github.io//2009/10/13/case-study-actionscript-3-performance-optimization</id>
    <content type="html"><![CDATA[<p>Prompted by some of the work from <a href="http://www.gskinner.com/blog/">Grant Skinner</a> (in particular his <a href="http://gskinner.com/blog/archives/2004/06/conference_sess.html">FOTB 2009 session</a>) and <a href="http://www.bytearray.org/">Thibault Imbert</a>, I have been doing a lot of research lately into optimizing ActionScript 3 content. Not just how to make it run faster, but how to approach the process of optimization.</p>

<p>I am also starting to work on a small project which works with pixel data from images, and on which I anticipate performance might be an issue when working with larger images. I figured this would be a good opportunity to use some of the early code as a case study. I wanted to post the process and results here.</p>

<!--more-->


<p>The task that I will focus on is grabbing a palette of 16 colors from an image, created by averaging the colors within that image. Upon searching on google, I found a <a href="http://blog.soulwire.co.uk/flash/actionscript-3/extract-average-colours-from-bitmapdata/">very good solution over at soulwire.co.uk</a>, which I will use as the base for creating the palette. I want to point out that the original code targeted Flash Player 9 (and thus couldn&rsquo;t take advantage of some things such as Vectors), and already ran pretty blazingly fast.</p>

<p>I am using Grant Skinner&rsquo;s <a href="http://www.gskinner.com/blog/archives/2009/04/as3_performance.html">performance test harness</a> to profile performance. Each test is run 50 times, and is tested in Flash Player MAC 10,0,32,18 (debug) in the browser.</p>

<p>You can download all of the code from <a href="/blog/files/examples/PixelSort.zip">here</a>.</p>

<p>First, here is the original test case, based on soulwire&rsquo;s code:</p>

<p>``` actionscript
/*</p>

<pre><code>Code adapted from:
http://blog.soulwire.co.uk/flash/actionscript-3/colourutils-bitmapdata-extract-colour-palette/
</code></pre>

<p>*/</p>

<p>package
{</p>

<pre><code>import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.Event;
import flash.geom.Rectangle;
import flash.geom.Point;

import com.gskinner.utils.PerformanceTest;

public class PixelSort extends Sprite
{

    [Embed(source="../graphics/image.jpg")]
    public var TestImage:Class;

    public function PixelSort()
    {
        addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);
    }

    private var d:BitmapData;
    private function onAddedToStage(evet:Event):void
    {
        removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);

        var b:Bitmap = new TestImage();

        d = b.bitmapData;

        var perfTest:PerformanceTest = PerformanceTest.getInstance();
        perfTest.out = trace;
        perfTest.testFunction(run, 50, "averagecolors", "averagecolors");           
    }

    private function run():void
    {
        var out:Array = averagecolors(d, 16);
    }

    public function averageColour( source:BitmapData ):uint
    {
        var red:Number = 0;
        var green:Number = 0;
        var blue:Number = 0;

        var count:Number = 0;
        var pixel:Number;

        for (var x:int = 0; x &lt; source.width; x++)
        {
            for (var y:int = 0; y &lt; source.height; y++)
            {
                pixel = source.getPixel(x, y);

                red += pixel &gt;&gt; 16 &amp; 0xFF;
                green += pixel &gt;&gt; 8 &amp; 0xFF;
                blue += pixel &amp; 0xFF;

                count++
            }
        }

        red /= count;
        green /= count;
        blue /= count;

        return red &lt;&lt; 16 | green &lt;&lt; 8 | blue;
    }       

    public function averagecolors( source:BitmapData, colors:int ):Array
    {
        var averages:Array = new Array();
        var columns:int = Math.round( Math.sqrt( colors ) );

        var row:int = 0;
        var col:int = 0;

        var x:int = 0;
        var y:int = 0;

        var w:int = Math.round( source.width / columns );
        var h:int = Math.round( source.height / columns );

        for (var i:int = 0; i &lt; colors; i++)
        {
            var rect:Rectangle = new Rectangle( x, y, w, h );

            var box:BitmapData = new BitmapData( w, h, false );
            box.copyPixels( source, rect, new Point() );

            averages.push( averageColour( box ) );
            box.dispose();

            col = i % columns;

            x = w * col;
            y = h * row;

            if ( col == columns - 1 ) row++;
        }

        return averages;
    }       
}
</code></pre>

<p>}
```</p>

<p>And here is the initial performance test:</p>

<pre>––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
averagecolors (50 iterations)                                           
Player version: MAC 10,0,32,18 (debug)
averagecolors                                                           
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
method...................................................ttl ms...avg ms
averagecolors                                              1264    25.28
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––</pre>


<p>First, considering what the code is doing, it is already pretty fast, taking only 25 ms to split the image into a grid, and loop through all of the pixels and averaging the values. However, there is probably some room for improvement, especially given that the original code targets Flash Player 9 and thus cant take care of Flash Player 10 optimizations such as using Vectors.</p>

<p>Now, the first thing I would normally do is to profile the SWF using the profiler in Flash Builder to find out where the most time is being sent. However, in this case, there are only two methods that do anything, <em>averageColors</em> and <em>averageColor</em>. <em>averageColors</em> is called once, while <em>averageColor</em> is called once for each swatch we want to create (in this case 16), and ends up looping over each pixel in the image (over those 16 calls). So these are the two areas we will focus on, with particular attention directed to <em>averageColor</em>.</p>

<p>The first thing I did was look at updating the content to Flash Player 10 by converting all of the Arrays to Vectors. I expected to get a decent boost from this, but the improvement was minimal.</p>

<p>Within the <em>averageColors</em> method, I looked at reusing the <em>Point</em>, <em>Rectangle</em> and <em>BitmapData</em> instances, instead of creating new ones on each iteration of the loop. Again, on the desktop this didn&rsquo;t really make any difference. However, one thing to consider is that on a mobile device where memory allocation can be more expensive (and there is less RAM altogether), this change may have had a bigger impact (which I didnt test). This leads to an important point. It is important to test performance on the platforms which you are targeting, as some optimizations can have a different impact depending on where the content is running.</p>

<p>Next, I set the <em>averageColor</em> and <em>averageColors</em> methods as <em>final</em>, which allows them too be looked up at compile time (as opposed to runtime), this led to small improvement in performance, but again, not really anything significant.</p>

<p>At this point, I was getting a very slight performance improvement, but not really anything that mattered (basically, small enough to be insignificant),</p>

<pre>––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
averagecolors (50 iterations)                                          
Player version: MAC 10,0,32,18 (debug)
averagecolors                                                           
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
method...................................................ttl ms...avg ms
averagecolors                                              1224    24.48
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––</pre>


<p>Next, I moved on to the <em>averageColor</em> method, where I expected (and hoped) to have better results, as this is where the bulk of the work occurs.</p>

<p>First I converter some of the Numbers to ints and uints in places where Numbers were not needed. This led to a small improvement.</p>

<pre>––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
averagecolors (50 iterations)                                           
Player version: MAC 10,0,32,18 (debug)
averagecolors                                                           
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
method...................................................ttl ms...avg ms
averagecolors                                              1190    23.80
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––</pre>


<p>Next, I changed the <code>bitmapData.getPixel</code> call to use <code>bitmapData.getVector</code>. Doing this then allowed me to loop through the pixels using a single loop, instead of a nested double loop, and also eliminated a <em>getPixel</em> call for each pixel. I used a <em>for each</em> loop to loop through the pixel color values.</p>

<p>This provided another slight improvement (although not quite as much as I expected). We are now making some small gains.</p>

<pre>––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
averagecolors (50 iterations)                                           
Player version: MAC 10,0,32,18 (debug)
averagecolors                                                           
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
method...................................................ttl ms...avg ms
averagecolors                                              1137    22.74
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––</pre>


<p>Next, I decided to try a <em>for</em> loop, instead of a <em>for each</em> loop.</p>

<pre>––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
averagecolors (50 iterations)                                           
Player version: MAC 10,0,32,18 (debug)
averagecolors                                                           
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
method...................................................ttl ms...avg ms
averagecolors                                               282     5.64
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––</pre>


<p>Wow! As you can see, that makes a huge difference.</p>

<p>Finally, I explicitly cast <em>i</em> to an <em>int</em> when pulling the value from the Vector. This gave a small improvement, but again, nothing significant:</p>

<pre>––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
averagecolors (50 iterations)                                           
Player version: MAC 10,0,32,18 (debug)
averagecolors                                                           
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
method...................................................ttl ms...avg ms
averagecolors                                               268     5.36
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––</pre>


<p>I tried a couple of more optimizations in the method, around converting division operations to multiplication operation, and replacing <code>Math.round</code> calls but in this case it didnt make any difference.</p>

<p>I also looked at caching some constants used in some of the bitwise operations, changing</p>

<p><code>actionscript
red += pixel &gt;&gt; 16 &amp; 0xFF;
green += pixel &gt;&gt; 8 &amp; 0xFF;
</code></p>

<p>to:</p>

<p>``` actionscript
private var s16:Number = 16 &amp; 0xFF;
private var s8:Number = 8 &amp; 0xFF;</p>

<p>red += pixel >> s16;
green += pixel >> s8;
```</p>

<p>First, that optimization actually produces the wrong result (I had my operator precedence backwards). Second, it was actually slower:</p>

<pre>––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
averagecolors (50 iterations)                                           
Player version: MAC 10,0,32,18 (debug)
averagecolors                                                           
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
method...................................................ttl ms...avg ms
averagecolors                                               349     6.98
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––</pre>


<p>There are two lessons from this. First, make sure your optimizations produce the same results (ideally by creating and using unit tests). Second, bitwise operations are really, really fast. In this case, they are even faster than doing a variable lookup.</p>

<p>So, after going through the code, and applying a number of different optimizations, I was able to improve performance from an average of 25.28 ms, to 5.36 ms, an improvement of about 470%.</p>

<p>Here is the final code:</p>

<p>``` actionscript
/*</p>

<pre><code>Code adapted from:
http://blog.soulwire.co.uk/flash/actionscript-3/colourutils-bitmapdata-extract-colour-palette/
</code></pre>

<p>*/</p>

<p>package
{</p>

<pre><code>import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.Event;
import flash.geom.Rectangle;
import flash.geom.Point;

import com.gskinner.utils.PerformanceTest;

public class PixelSort extends Sprite
{

    [Embed(source="../graphics/image.jpg")]
    public var TestImage:Class;

    public function PixelSort()
    {
        addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);
    }

    private var d:BitmapData;
    private function onAddedToStage(evet:Event):void
    {
        removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);

        var b:Bitmap = new TestImage();

        d = b.bitmapData;

        var perfTest:PerformanceTest = PerformanceTest.getInstance();
        perfTest.out = trace;
        perfTest.testFunction(run, 50, "averagecolors", "averagecolors");           
    }

    private function run():void
    {
        var out:Vector.&lt;uint&gt; = averagecolors(d, 16);
    }       

    public final function averageColour( source:BitmapData ):uint
    {
        var red:Number = 0;
        var green:Number = 0;
        var blue:Number = 0;

        var count:int = 0;
        var pixel:uint;

        var pixels:Vector.&lt;uint&gt; = source.getVector(new Rectangle(0,0, source.width, source.height));
        var len:int = pixels.length;

        for(var i:int = 0; i &lt; len; i++)
        {   
            pixel = pixels[int(i)];

            red += pixel &gt;&gt; 16 &amp; 0xFF;
            green += pixel &gt;&gt; 8 &amp; 0xFF;
            blue += pixel &amp; 0xFF;

            count++;
        }

        red /= count;
        green /= count;
        blue /= count;

        return red &lt;&lt; 16 | green &lt;&lt; 8 | blue;
    }       

    public final function averagecolors( source:BitmapData, colors:int ):Vector.&lt;uint&gt;
    {

        var averages:Vector.&lt;uint&gt; = new Vector.&lt;uint&gt;(colors, false);
        var columns:int = Math.round( Math.sqrt( colors ) );

        var row:int = 0;
        var col:int = 0;

        var x:int = 0;
        var y:int = 0;

        var w:int = Math.round( source.width / columns );
        var h:int = Math.round( source.height / columns );

        var p:Point = new Point();
        var rect:Rectangle = new Rectangle(0,0,0,0);
        var box:BitmapData = new BitmapData( w, h, false );

        for (var i:int = 0; i &lt; colors; i++)
        {
            rect.x = x;
            rect.y = y;
            rect.width = w;
            rect.height = h;

            box.copyPixels( source, rect, p );

            averages[i] =  averageColour( box );

            col = i % columns;

            x = w * col;
            y = h * row;

            if ( col == columns - 1 ) 
            {
                row++;
            }
        }
        box.dispose();
        return averages;
    }       
}
</code></pre>

<p>}
```</p>

<p><strong>Lessons learned</strong></p>

<p><strong>Profile content to isolate bottlenecks</strong> : I skipped that step in this case since my code consisted of only two methods, but even in that case, the most significant improvement came from a single optimization. Profile so you know where to focus your efforts.</p>

<p><strong>Test and profile all optimizations</strong> : Make sure to test performance after each optimization, as optimizations do not always have the desired effect.</p>

<p><strong>Test on target devices and platforms</strong> : Optimizations can have a different impact on where they are run. This includes browser, platform and device, as well as player type (debug vs release). For example, when testing directly from Flash Authoring, results where significantly slower than when testing in the browser.</p>

<p><strong>Test the results of the optimizations</strong> : Make sure that your optimizations do not break your code or content. The best way to do this is by using unit tests and running them after each optimization.</p>

<p>There is still some potential for optimization. In particular, since the code is essentially looping over all of the pixels of a bitmap and then doing some math operations on their values, this could be a good candidate for porting to PixelBender.</p>

<p>If you have any additional optimizations, questions or suggestions, post them in the comments.</p>

<p>Also, make sure to check out <a href="http://blog.soulwire.co.uk/">soulwire&rsquo;s blog</a>, as he is doing some very cool stuff with ActionScript 3 and Flash.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parsing and Displaying BMP Files via ActionScript]]></title>
    <link href="http://mikechambers.github.io//2009/09/17/parsing-and-displaying-bmp-files-via-actionscript/"/>
    <updated>2009-09-17T13:29:01-07:00</updated>
    <id>http://mikechambers.github.io//2009/09/17/parsing-and-displaying-bmp-files-via-actionscript</id>
    <content type="html"><![CDATA[<p>I dont have a formal computer science training / education, so I never got the chance to learn about working with low level data structures (bits and bytes). I have wanted to learn this for some time, but had difficulty finding resources for it which didnt assume I had a computer science degree.</p>

<p>Well, yesterday, FITC posted <a href="http://www.fitc.ca/media/">all of the video sessions from FITC Toronto</a>, and I spent some time watching Lee Brimelow&rsquo;s presentation on working with ByteArrays. It is a really great session, that provides a clear and solid foundation and understanding of working with ByteArrays and bits and bytes.</p>

<p>Anyways, after watching Lee&rsquo;s session, it all finally clicked for me, and I spent some time last night putting together a simple parser that would dynamically load and display a <a href="http://en.wikipedia.org/wiki/BMP%5Ffile%5Fformat">24Bit BMP image file</a> within Flash.</p>

<!--more-->


<p>I wanted to post the code below, along with complete comments, in order to provide a simple, real world example for anyone else interested in learning how to work with lower level file formats.</p>

<p>The code requires Adobe AIR (so I can load the BMP directly). In order to convert to the Flash Player in the browser, just replace the File loading with FileReference.browse.</p>

<p>``` actionscript
package
{</p>

<pre><code>import flash.filesystem.File;
import flash.filesystem.FileStream;
import flash.filesystem.FileMode;

import flash.display.Sprite;
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.utils.Endian;

import flash.geom.Rectangle;

[SWF(width='550', height='400', backgroundColor='#FFFFFF', frameRate='12')]
public class BMPViewer extends Sprite
{
    private static const MAGIC_NUMBER:String = "BM";
    private static const BMP_DATA_OFFSET_POSITION:int = 0xA;
    private static const WIDTH_POSITION:int = 0x12;
    private static const HEIGHT_POSITION:int = 0x16;

    public function BMPViewer()
    {
        loadBMP();
        super();
    }

    /*
        Loads and reads a 24 Bit bitmap file.

        Based on BMP info from:
        http://en.wikipedia.org/wiki/BMP%5Ffile%5Fformat
    */
    private function loadBMP():void
    {
        //Load BMP. This requires AIR.
        //Use FileReference.browse for
        //Flash Player
        var bmpFile:File = new File("app:/image.bmp");
        var fs:FileStream = new FileStream();

        //BMP files are Little Endian, which means their
        //least significant byte is first (right to left)
        fs.endian = Endian.LITTLE_ENDIAN;

        //open the file in READ mode
        fs.open(bmpFile, FileMode.READ);

        //check the first two bytes to make sure
        //it is a valid BMP file
        if(fs.readUTFBytes(2) != MAGIC_NUMBER)
        {
            trace("FAIL : NOT A BMP FILE");

            //not a BMP file, close steam
            //and exit
            fs.close();
            return;
        }

        //note, we could also grab the length from the 
        //header and make sure the file was the correct
        //length

        //change the cursors position to the point
        //in the header that contains the value / offset
        //of where the actual bitmap data begins
        //read in the 4 Bytes that contain the value
        fs.position = BMP_DATA_OFFSET_POSITION;
        var dataPosition:int = fs.readInt();

        //set cursor position to where the BMP
        //width is stored
        fs.position = WIDTH_POSITION;

        //read in the 4 Bytes that contain the width
        var bmpWidth:int = fs.readInt();

        //read in the 4 Bytes that contain the height
        var bmpHeight:int = fs.readInt();

        //set cursor to where the BMP pixel data begins
        fs.position = dataPosition;

        var row:int = 0;
        var column:int = 0;

        //every row length in a BMP file must bee a multiple
        //of 4 (see the spec). So, we need to determine how much
        //padding we need to add at the end of each line. 
        var padding:int = (bmpWidth % 4);

        //create a fixed length Vector to store the pixel
        //values as we read them.
        var pixels:Vector.&lt;uint&gt; = new Vector.&lt;uint&gt;(bmpWidth * bmpHeight, true);

        //loop through data (rows and columns)
        //note that data stored in BMP is backwards to Flash and is
        //stored from bottom row up, not top row down.
        //So we have to loop backwards
        var counter:int = 0;
        for(var i:int = bmpHeight; i &gt; 0; i--)
        {
            for(var k:int = 0; k &lt; bmpWidth; k++)
            {


                var position:int = ((i - 1) * bmpWidth) + k;
                /*
                    This is the original code that I had which works fine
                    but is not as effecient as what I have now.

                    Basically, Pixels are stored within 3 sucessive Bytes
                    in a BMP file, with one Byte each for Blue, Green and
                    Red values (in that order).

                    So, this reads the Bytes for each pixel, one at a time
                    and then combines them into a single value which is
                    the combined RGB pixel value.

                    I left the code as I think it make it a little easier to
                    understand what is going on, as well as how some of these
                    calls can be optimized.
                */

                /*
                var blue:int = fs.readUnsignedByte();
                var green:int = fs.readUnsignedByte();
                var red:int = fs.readUnsignedByte();

                pixels[position] = (red &lt;&lt; 16 ^ green &lt;&lt; 8 ^ blue);
                */


                /*
                    Here is the final code which is more efficient, as it only
                    needs to make 2 read calls in order to get the values.

                    Thanks to Thibault Imbert (bytearray.org) for pointing out
                    and helping me understand the optimization.
                */

                //bytes in file are in Blue, Green, Red order
                //int is 32 bits (8 bytes). So, we store the first two bytes of the pixel
                // (which contain the Red value), and
                //then shift everything over 1 byte (8bits) to make room for
                //the green and blue values (remember the file is little endian), which we
                // then write into the int in the right position
                //The final value has the colors in the correct order (Red, Green, Blue)

                var pixelValue:uint = fs.readUnsignedByte() | fs.readUnsignedShort() &lt;&lt; 8;
                pixels[position] = pixelValue;
            }

            //we are at the end of the row, so now we have to move the cursor
            //forward so it ends on a multiple of 4
            if(padding)
            {
                fs.position += padding;
            }
        }

        //done reading file, close stream.
        fs.close();

        //create a Rectangle with width / height of Bitmap
        var rect:Rectangle = new Rectangle(0, 0, bmpWidth, bmpHeight);

        //create the BitmapData object to hold hold the BMP data.
        //we do a red fill here so it is easier to see if we have any errors
        //in our code
        var bmpData:BitmapData = new BitmapData(bmpWidth, bmpHeight, false, 0xFF0000);

        //copy the BMP pixel data into the BitmapData
        bmpData.setVector(rect, pixels);

        //create a new Bitmap instance using the BitmapData
        var bitmap:Bitmap = new Bitmap(bmpData);
        bitmap.x = 10;
        bitmap.y = 10;

        //add Bitmap to the display list
        addChild(bitmap);
    }
}
</code></pre>

<p>}
```</p>

<p>You can download the example from <a href="/blog/files/examples/BMPViewer.zip">here</a>.</p>

<p>Thanks to <a href="http://www.theflashblog.com">Lee</a> for his presentation, and <a href="http://www.bytearray.org">Thibault Imber</a>t who helped me understand some of the details around endianes, as well as made some suggestions for optimizations.</p>

<p>If you are interested in learning more, I strong suggest watching <a href="http://www.fitc.ca/media/">Lee&rsquo;s FITC Presentation</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Converting From Matrix3D to Matrix in ActionScript 3]]></title>
    <link href="http://mikechambers.github.io//2009/09/09/converting-from-a-matrix3d-to-matrix-in-actionscript-3/"/>
    <updated>2009-09-09T13:37:01-07:00</updated>
    <id>http://mikechambers.github.io//2009/09/09/converting-from-a-matrix3d-to-matrix-in-actionscript-3</id>
    <content type="html"><![CDATA[<p>For the past month or two, I have been spending time building a game (something I havent done since my Flash 4 days). This has really been a lot of fun, as it has allowed me to use some of the Flash Player APIs which I really haven&rsquo;t had a chance or need to use before.</p>

<p>One thing which I have been (slowly) learning about are using Matrix transformations on DisplayObjects. I made a post earlier showing how (with much, much help from <a href="http://www.senocular.com/">Senocular</a>), I was able to <a href="http://www.mikechambers.com/blog/2009/06/24/using-bitmapdata-hittest-for-collision-detection/">use Matrix to do hit tests using BitmapData.hitTest on DisplayObjects</a> which have had transformations applied to them (in this case, rotation).</p>

<p>Well, I recently had the need to convert some of my DisplayObjects to use the 2.5D APIs (by setting the z property to a value). Unfortunately, this ended up breaking a lot of my code, mostly because of how it changes how transformations are applied to a DisplayObject. Specifically, when you set the <code>DisplayObject.z</code> property to any value, <code>DisplayObject.transform.matrix</code> will return null, and you must use <code>DisplayObject.transform.matrix3D</code> instead. Where this causes problems is when you are using APIs that expect to use a <code>Matrix</code> instance, as opposed to <code>Matrix3D</code> instance, such as <code>BitmapData.draw</code>.</p>

<!--more-->


<p>This is exactly the scenario I ran into, and this post will show one solution for how to convert from a Matrix3D to a Matrix instance, which can then be passed to the BitmapData.draw.</p>

<p>First, lets look at my original code:</p>

<p>``` actionscript
shipBmpData = new BitmapData(shipBounds.width,</p>

<pre><code>            shipBounds.height, true, 0);
</code></pre>

<p>var shipOffset:Matrix = ship.transform.matrix;
shipOffset.tx = ship.x &ndash; shipBounds.x;
shipOffset.ty = ship.y &ndash; shipBounds.y;</p>

<p>shipBmpData.draw(ship, shipOffset);
```</p>

<p>Basically, this draws the bitmap data for my ship into a <code>BitmapData</code> instance, taking into account any transformations which have been applied to the ship (in this case rotation). In my code, this bitmap data is cached, and then later used with <code>BitmapData.hitTest</code> for collision detection (not shown here).</p>

<p>However, as soon as I set the z property on the ship (which is a DisplayObject), this code will no longer work, as <code>ship.transform.matrix</code> will return null (since 3D transformations are now being used).</p>

<p>At first, I figured I would just change my code to access the Matrix3D instance like so:</p>

<p><code>actionscript
var shipOffset:Matrix3D = ship.transform.matrix3D;
</code></p>

<p>and then pass this to the <code>BitmapData.draw</code> API. However, I was quickly reminded (by the compiler) that <code>Matrix3D</code> does not inherit from <code>Matrix</code>, and thus cannot be passed to <code>BitmapData.draw</code>.</p>

<p>Because of this I needed to convert from a <code>Matrix3D</code> to a <code>Matrix</code> instance, which could then be passed to <code>BitmapData.draw</code>. After some help from <a href="http://www.unitzeroone.com/blog/">Ralph Hauwert</a> (who tracked down a couple of bugs) I was able to get it working.</p>

<p>Before I show the code, it will be useful to look at which values <code>Matrix</code> and <code>Matrix3D</code> contain. First, here are the values held by a <code>Matrix</code> instance:</p>

<pre>
a  c  tx
b  d  ty
u  v  w
</pre>


<p>You can find a description of the properties in the <a href="http://livedocs.adobe.com/flex/3/langref/flash/geom/Matrix.html#propertySummary">Matrix docs</a>.</p>

<p>Here are the values held by a Matrix3D instance:</p>

<pre>
scaleX    0       0          tx
0         scaleY  0          ty
0         0       scaleZ     tz
0         0       0          tw
</pre>


<p>From the <a href="http://help.adobe.com/en_US/AS3LCR/Flash_10.0/flash/geom/Matrix3D.html">Matrix3D docs</a>:</p>

<blockquote><p>The Matrix3D class uses a 4x4 square matrix: a table of four rows and columns of numbers that hold the data for the transformation. The first three rows of the matrix hold data for each 3D axis (x,y,z). The translation information is in the last column. The orientation and scaling data are in the first three columns. The scaling factors are the diagonal numbers in the first three columns</p></blockquote>

<p>Basically, in addition to holding values for x and y, the <code>Matrix3D</code> class also has slots for z properties. Because the <code>Matrix</code> is a 3x3 matrix, and the <code>Matrix3D</code> is a 4x4 matrix converting from <code>Matrix3d</code> to <code>Matrix</code> means that we will have to discard some information. Luckily, in my case, I didnt need the z information, so i was able to discard it and map the related x, y values to the <code>Matrix</code> instance. We can then pass this new <code>Matrix</code> instance to the <code>BitmapData.draw</code> class.</p>

<p>For our purposes, the <code>Matrix3D</code> mapping to <code>Matrix</code> is:</p>

<pre>
a  c  0          tx
b  d  0          ty
0  0  scaleZ     tz
0  0  0          tw
</pre>


<p>Here is the code that maps between the two:</p>

<p>``` actionscript
var shipOffset:Matrix3D = ship.transform.matrix3D;</p>

<p>var rawMatrixData:Vector.<Number> = shipOffset.rawData;</p>

<p>var matrix:Matrix = new Matrix();
matrix.a = rawMatrixData[0];
matrix.c = rawMatrixData<a href="http://www.senocular.com/">1</a>;
matrix.tx = ship.x &ndash; shipBounds.x;</p>

<p>matrix.b = rawMatrixData<a href="http://livedocs.adobe.com/flex/3/langref/flash/geom/Matrix.html#propertySummary">4</a>;
matrix.d = rawMatrixData<a href="http://help.adobe.com/en_US/AS3LCR/Flash_10.0/flash/geom/Matrix3D.html">5</a>;
matrix.ty = ship.y &ndash; shipBounds.y;</p>

<p>ship.transform.matrix3D = null;
shipBmpData.draw(ship, matrix);
ship.transform.matrix3D = shipOffset;
```</p>

<p>Basically, we get an instance of the <code>Matrix3D</code> class for the <code>DisplayObject</code>. We then access the raw data of the <code>Matrix3D</code> instance, and copy it into a new <code>Matrix</code> instance (ignoring and dropping the z values), and apply the transformation corrections in the process.</p>

<p>We can then pass this new <code>Matrix</code> instance to the <code>BitmapData.draw</code> API. However, as you probably noticed in the code, I had to first do an additional step. Specifically:</strike ></p>

<p><code>actionscript
ship.transform.matrix3D = null;
shipBmpData.draw(ship, matrix);
ship.transform.matrix3D = shipOffset;
</code></p>

<p>Before we draw the data to the <code>BitmapData</code> instance, we have to clear out the existing <code>Matrix3D</code> applied to the <code>DisplayObject</code>. This is to work around a bug discovered by <a href="http://www.unitzeroone.com/blog/">Ralph Hauwert</a>. When passing a <code>DisplayObject</code> which does not have a <code>Matrix3D</code> transformation (as in our first example) to <code>BitmapData.draw</code>, any transformations on the <code>DisplayObject</code> ARE NOT taken into account when drawing. However, when the the <code>DisplayObject</code> does have a <code>Matrix3D</code> transformation applied to it (such as when the z property has been set to a value), then any transformations ARE applied when drawing to <code>BitmapData.draw</code>. Because of this, we have to first store the <code>Matrix3D</code> associated with the DisplayObject, set it to null, draw the <code>DisplayObject</code> to the <code>BitmapData</code> instance, and then reapply the <code>Matrix3D</code> to the <code>DisplayObject</code>.</p>

<p><strike><strong>Update</strong>: as <a href="http://www.mikechambers.com/blog/2009/09/09/converting-from-a-matrix3d-to-matrix-in-actionscript-3/#comment-16700">Ben Garney points out in the comments</a>, since the transformation is applied to <code>BitmapData.draw</code> when <code>Matrix3D</code> is set, all we need to do is pass in either an identiy matrix, or null to the second argument of the API. So, in my case, this solves my problems, and removes the need to convert bewteen the matrix types.</strike></p>

<p><strike>The updated code is simply:</strike>
``` actionscript
shipBmpData = new BitmapData(shipBounds.width,</p>

<pre><code>            shipBounds.height, true, 0);
</code></pre>

<p>shipBmpData.draw(ship, null);
```</p>

<p><strike>which turns out to be much less complex than when you use the 2D APIs. However, the technique above for converting between matrix types is still valid.</strike></p>

<p><strong>Update 2</strong>: It turns out passing in null or an identity matrix to <code>BitmapData.draw</code>. does not work correctly.</p>

<p>Of course, this is not always necessary when converting from a <code>Matrix</code> instance to a <code>Matrix3D</code> instance, but in my case it was. As you can imagine, this can have some significant performance implications, both because of memory allocation and deallocation, as well as the fact that removing the <code>Matrix3D</code>, even temporarily, changes how the <code>DisplayObject</code> is rendered.</p>

<p>Right now, this trade off is ok in my case, although I am not sure if it will be for the long term. Again, in my case, I may need to look at some re-architecting so I don&rsquo;t have to work around this issue (such as nesting clips and cacheing the parent <code>BitmapData</code>, so I don&rsquo;t have to apply the transformations).</p>

<p>Anyways, I am just learning the implications of using the 2.5D APIs in the Flash Player. This is an area where there is not currently a lot of information or documentation, especially information on the implications of moving from 2D to 2.5D APIs. Hopefully this will be useful.</p>

<p>Here are a couple of other resources which I found useful:</p>

<p><a href="http://adobe.com/go/AS3LR">API docs for Matrix, Matrix3D, Transformation and DisplayObject</a>.</p>

<p><a href="http://www.bytearray.org/wp-content/projects/fp10-session/">Thibault Imbert&rsquo;s Flash Player 10 Presentation</a>, which has some good info on the 2.5D APIS.</p>

<p><a href="http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WSF24A5A75-38D6-4a44-BDC6-927A2B123E90.html">Flash CS4 Docs : Working in three dimensions</a></p>

<p>As I mentioned above, I am still getting my head around some of this stuff, so if you have any clarifications or corrections, post them in the comments.</p>
]]></content>
  </entry>
  
</feed>
